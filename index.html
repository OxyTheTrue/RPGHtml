// --- SISTEMA DE ÁUDIO SINTETIZADO ---
const AudioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    const osc = AudioCtx.createOscillator();
    const gain = AudioCtx.createGain();
    osc.connect(gain);
    gain.connect(AudioCtx.destination);

    const now = AudioCtx.currentTime;

    switch(type) {
        case 'atk':
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(); osc.stop(now + 0.1);
            break;
        case 'mag':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(); osc.stop(now + 0.2);
            break;
        case 'hit':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(20, now + 0.2);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(); osc.stop(now + 0.2);
            break;
        case 'heal':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
            break;
        case 'buy':
            osc.type = 'square';
            osc.frequency.setValueAtTime(880, now);
            osc.frequency.setValueAtTime(1100, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(); osc.stop(now + 0.2);
            break;
        case 'lvl':
            [440, 554, 659, 880].forEach((f, i) => {
                const o = AudioCtx.createOscillator();
                const g = AudioCtx.createGain();
                o.connect(g); g.connect(AudioCtx.destination);
                o.frequency.setValueAtTime(f, now + (i * 0.1));
                g.gain.setValueAtTime(0.05, now + (i * 0.1));
                g.gain.linearRampToValueAtTime(0, now + (i * 0.1) + 0.2);
                o.start(now + (i * 0.1)); o.stop(now + (i * 0.1) + 0.2);
            });
            break;
    }
}

// --- VARIÁVEIS DO JOGO ---
let p, e, isTyping = false, isDefending = false;
const types = ['fogo', 'agua', 'terra'];
const elems = { 
    fogo: { cor: '#ff9f43', fraqueza: 'agua', resiste: 'terra' }, 
    agua: { cor: '#54a0ff', fraqueza: 'terra', resiste: 'fogo' }, 
    terra: { cor: '#1dd1a1', fraqueza: 'fogo', resiste: 'agua' } 
};

const monsterTemplates = [
    { name: "Ratazana", hpMin: 5, hpMax: 8, strMin: 1.2, strMax: 2.5, minLv: 1, type: 'basic', img: "ratazana gigante.png" },
    { name: "Esqueleto", hpMin: 8, hpMax: 12, strMin: 2, strMax: 3.5, minLv: 1, type: 'basic', img: "esqueleto.png" },
    { name: "Ogro", hpMultMin: 1.0, hpMultMax: 1.2, strMultMin: 0.9, strMultMax: 1.1, minLv: 5, type: 'proportional', img: "ogro.png" },
    { name: "Vampiro", hpMultMin: 1.1, hpMultMax: 1.3, strMultMin: 0.8, strMultMax: 1.0, minLv: 10, type: 'proportional', img: "vampiro.png" }
];

window.onload = () => { if(localStorage.getItem('rpg_save')) document.getElementById('continue-btn').style.display = 'flex'; };

function startNewGame() {
    p = { lv: 1, hp: 10, maxHp: 10, mana: 20, maxMana: 20, str: 4, int: 5, luk: 3, spd: 3, vit: 1, xp: 0, nextXp: 50, furia: 0, gold: 0, inventory: [], pendingPoints: 0, levels: { str: 1, spd: 1, int: 1, luk: 1, vit: 1 }, buffs: { boots: 0, shield: 0, coin: 0 } };
    showGame(); spawnMonster();
}

function restartGame() {
    p.hp = p.maxHp; p.mana = p.maxMana; p.xp = 0; p.gold = 0; p.furia = 0; p.inventory = []; p.pendingPoints = 0; p.buffs = { boots: 0, shield: 0, coin: 0 };
    document.getElementById('death-modal').style.display = 'none'; document.getElementById('overlay').style.display = 'none';
    updateUI(); spawnMonster(); typeLog("Você renasce!", "#ffa502");
}

function exitToMenu() { localStorage.removeItem('rpg_save'); location.reload(); }
function saveAndExit() { const saveData = { p, e }; localStorage.setItem('rpg_save', JSON.stringify(saveData)); location.reload(); }

function loadGame() {
    const saved = JSON.parse(localStorage.getItem('rpg_save'));
    if(saved) { p = saved.p; e = saved.e; if(!p.buffs) p.buffs = { boots: 0, shield: 0, coin: 0 }; showGame(); if (e && e.img) document.getElementById('enemy-img').src = e.img; updateUI(); typeLog("Progresso carregado!", "#2ed573"); toggleButtons(false); }
}

function showGame() { document.getElementById('start-menu').style.display = 'none'; document.getElementById('game-ui').style.display = 'flex'; }
function openShop() { if(p.hp <= 0) return; document.getElementById('overlay').style.display = 'block'; document.getElementById('shop-modal').style.display = 'block'; }
function closeShop() { document.getElementById('overlay').style.display = 'none'; document.getElementById('shop-modal').style.display = 'none'; }

function buyItem(type) {
    const items = {
        potion: { cost: 10, name: "Poção", heal: 15, icon: "fa-flask" },
        boots: { cost: 25, name: "Bota Agilidade", type: "boots", dur: 5, icon: "fa-boot-heeled" },
        shield: { cost: 30, name: "Escudo Prata", type: "shield", dur: 2, icon: "fa-shield-halved" },
        coin: { cost: 40, name: "Moeda Sorte", type: "coin", dur: 3, icon: "fa-coins" }
    };
    const item = items[type];
    if(p.gold >= item.cost && p.inventory.length < 5) {
        p.gold -= item.cost; p.inventory.push(item);
        playSound('buy'); updateUI(); typeLog(`Comprou ${item.name}!`, "#2ed573");
    } else { typeLog(p.inventory.length >= 5 ? "Mochila cheia!" : "Ouro insuficiente!", "#ff4757"); }
}

function useItem(index) {
    if(p.inventory[index]) {
        const item = p.inventory[index];
        if(item.heal) { p.hp = Math.min(p.maxHp, p.hp + item.heal); playSound('heal'); typeLog(`Usou ${item.name}: +${item.heal} HP`, "#2ed573"); }
        else { p.buffs[item.type] = item.dur; playSound('mag'); typeLog(`Ativou ${item.name}!`, "#ffa502"); }
        p.inventory.splice(index, 1); updateUI();
    }
}

async function typeLog(text, color = "#00ff9d") {
    isTyping = true; const log = document.getElementById('game-log'); const line = document.createElement('div');
    line.style.color = color; line.innerHTML = "> "; log.appendChild(line);
    for (let char of text) { line.innerHTML += char; log.scrollTop = log.scrollHeight; await new Promise(r => setTimeout(r, 15)); }
    isTyping = false; await new Promise(r => setTimeout(r, 400));
}

async function spawnMonster() {
    let avail = monsterTemplates.filter(m => p.lv >= m.minLv); let data = avail[Math.floor(Math.random() * avail.length)];
    const randomElem = types[Math.floor(Math.random() * types.length)];
    let finalHp = data.type === 'proportional' ? Math.ceil(p.maxHp * (Math.random() * (data.hpMultMax - data.hpMultMin) + data.hpMultMin)) : Math.floor(Math.random() * (data.hpMax - data.hpMin + 1)) + data.hpMin + (p.lv * 2);
    let finalStr = data.type === 'proportional' ? p.str * (Math.random() * (data.strMultMax - data.strMultMin) + data.strMultMin) : (Math.random() * (data.strMax - data.strMin) + data.strMin) + (p.lv * 0.3);
    e = { ...data, elem: randomElem, maxHp: finalHp, hp: finalHp, str: finalStr };
    document.getElementById('enemy-img').src = e.img; updateUI();
    await typeLog(`${e.name} apareceu!`, "#f1c40f"); toggleButtons(false);
}

function updateUI() {
    document.getElementById('p-hp-bar').style.width = (p.hp/p.maxHp*100) + "%";
    document.getElementById('p-mana-bar').style.width = (p.mana/p.maxMana*100) + "%";
    document.getElementById('p-furia-bar').style.width = p.furia + "%";
    document.getElementById('p-xp-bar').style.width = (p.xp/p.nextXp*100) + "%";
    document.getElementById('enemy-bar').style.width = (e.hp/e.maxHp*100) + "%";
    document.getElementById('p-lv').innerText = p.lv; document.getElementById('p-gold').innerText = p.gold;
    document.getElementById('p-hp').innerText = Math.ceil(p.hp); document.getElementById('p-max-hp').innerText = p.maxHp;
    document.getElementById('p-mana').innerText = Math.ceil(p.mana);
    ['str', 'spd', 'int', 'luk', 'vit'].forEach(s => document.getElementById('stat-'+s).innerText = p.levels[s]);
    document.querySelectorAll('.lvl-up-btn').forEach(btn => btn.style.display = p.pendingPoints > 0 ? 'block' : 'none');
    document.getElementById('enemy-name').innerText = e.name; document.getElementById('enemy-hp').innerText = Math.ceil(e.hp); document.getElementById('enemy-max-hp').innerText = e.maxHp;
    document.getElementById('enemy-badges').innerHTML = `<span class="badge" style="background: ${elems[e.elem].cor}">${e.elem.toUpperCase()}</span>`;
    document.querySelectorAll('.slot').forEach((s, i) => {
        if(p.inventory[i]) { s.innerHTML = `<i class="fa-solid ${p.inventory[i].icon}" style="color: ${p.inventory[i].heal ? '#2ed573' : '#ffa502'}"></i>`; s.classList.remove('empty'); }
        else { s.innerHTML = ""; s.classList.add('empty'); }
    });
}

function spendPoint(stat) {
    p.levels[stat]++; let gain = Math.floor(Math.random() * 3) + 1;
    if(stat === 'vit') p.maxHp += (gain * 5); else p[stat] += gain;
    p.lv++; p.xp = 0; p.nextXp = Math.floor(p.nextXp * 1.4); p.hp = p.maxHp; p.mana = p.maxMana; p.pendingPoints = 0;
    playSound('lvl'); updateUI(); spawnMonster();
}

async function playerAction(tipo) {
    if(isTyping || p.hp <= 0 || p.pendingPoints > 0) return;
    toggleButtons(true); isDefending = false;
    let dmg;
    if (tipo === 'fisico') { dmg = p.str * (Math.random() * 0.5 + 0.5); playSound('atk'); }
    else { if (p.mana < 10) { await typeLog("Sem mana!"); toggleButtons(false); return; } p.mana -= 10; dmg = p.int * (Math.random() * 0.4 + 0.8); playSound('mag'); if (elems[e.elem].fraqueza === tipo) dmg *= 1.5; }
    if (Math.random() * 100 < p.luk) { dmg *= 2; await typeLog("CRÍTICO!", "#ffa502"); }
    dmg = Math.ceil(dmg); applyDamageEffect(); e.hp -= dmg; updateUI(); await typeLog(`Dano: ${dmg}`);
    if(e.hp <= 0) await win(); else await enemyTurn();
}

async function enemyTurn() {
    let dodgeChance = (p.spd * 2) + (p.buffs.coin > 0 ? 40 : 0);
    if (Math.random() * 100 < dodgeChance) await typeLog("Esquivou!", "#3498db");
    else {
        let dmg = Math.ceil(e.str * (Math.random() * 0.3 + 0.7));
        if(isDefending) dmg = Math.ceil(dmg * 0.5);
        if(p.buffs.shield > 0) dmg = Math.ceil(dmg * 0.7);
        p.hp -= dmg; p.furia = Math.min(100, p.furia + 25); playSound('hit');
        await typeLog(`${e.name} causou ${dmg} dano`, "#ff4757");
    }
    for(let b in p.buffs) if(p.buffs[b] > 0) p.buffs[b]--;
    isDefending = false; updateUI();
    if(p.hp <= 0) setTimeout(() => { document.getElementById('overlay').style.display = 'block'; document.getElementById('death-modal').style.display = 'block'; }, 1000);
    else toggleButtons(false);
}

async function win() {
    let xpGanha = 25 + (p.lv * 15); let goldGanho = Math.floor(Math.random() * 7) + 2;
    p.xp += xpGanha; p.gold += goldGanho; playSound('lvl');
    await typeLog(`Vitória! +${xpGanha} XP | +${goldGanho}G`);
    if(p.xp >= p.nextXp) { p.pendingPoints++; await typeLog("LEVEL UP!", "#ffa502"); }
    if(p.pendingPoints === 0) spawnMonster(); else updateUI();
}

function playerRest() { toggleButtons(true); let ganho = Math.floor((p.int/2 + Math.random() * p.int) * (p.buffs.boots > 0 ? 1.25 : 1)); p.mana = Math.min(p.maxMana, p.mana + ganho); playSound('heal'); updateUI(); typeLog(`Recuperou ${ganho} mana`).then(() => enemyTurn()); }
function playerHeal() { if (p.mana < 8) return; toggleButtons(true); p.mana -= 8; let cura = Math.floor(p.int * 1.5); p.hp = Math.min(p.maxHp, p.hp + cura); playSound('heal'); updateUI(); typeLog(`Curou ${cura} HP`).then(() => enemyTurn()); }
function playerDefend() { toggleButtons(true); isDefending = true; typeLog("Defendendo!").then(() => enemyTurn()); }
function applyDamageEffect() { const img = document.getElementById('enemy-img'); img.classList.remove('take-damage'); void img.offsetWidth; img.classList.add('take-damage'); }
function toggleButtons(state) { document.querySelectorAll('#action-buttons button').forEach(b => b.disabled = state); }
